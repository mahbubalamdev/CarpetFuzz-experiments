{"rsent": [{"cmd": "jq", "option": "--seq", "sent": "This mode also parses the output of jq without the --seq option."}, {"cmd": "jq", "option": "--join-output", "sent": "Like -r but jq wont print a newline after each output."}, {"cmd": "jq", "option": "--argfile", "sent": "Use --slurpfile instead."}, {"cmd": "jq", "option": "--argfile", "sent": "(This option is like --slurpfile, but when the file has just one text, then that is used, else an array of texts is used as in --slurpfile.)"}, {"cmd": "jq", "option": "--run-tests", "sent": "This must be the last option given and does not honor all preceding options."}], "non_rsent": [{"cmd": "jq", "option": "--version", "sent": "Output the jq version and exit with zero."}, {"cmd": "jq", "option": "--seq", "sent": "Use the application/json-seq MIME type scheme for separating JSON texts in jqs input and output."}, {"cmd": "jq", "option": "--seq", "sent": "This means that an ASCII RS (record separator) character is printed before each value on output and an ASCII LF (line feed) is printed after every output."}, {"cmd": "jq", "option": "--seq", "sent": "Input JSON texts that fail to parse are ignored (but warned about), discarding all subsequent input until the next RS."}, {"cmd": "jq", "option": "--stream", "sent": "Parse the input in streaming fashion, outputing arrays of path and leaf values (scalars and empty arrays or empty objects)."}, {"cmd": "jq", "option": "--stream", "sent": "For example, a becomes [[],a], and [[],a,[b]] becomes [[0],[]], [[1],a], and [[1,0],b]."}, {"cmd": "jq", "option": "--stream", "sent": "This is useful for processing very large inputs."}, {"cmd": "jq", "option": "--stream", "sent": "Use this in conjunction with filtering and the reduce and foreach syntax to reduce large inputs incrementally."}, {"cmd": "jq", "option": "--slurp", "sent": "Instead of running the filter for each JSON object in the input, read the entire input stream into a large array and run the filter just once."}, {"cmd": "jq", "option": "--raw-input", "sent": "Dont parse the input as JSON."}, {"cmd": "jq", "option": "--raw-input", "sent": "Instead, each line of text is passed to the filter as a string."}, {"cmd": "jq", "option": "--raw-input", "sent": "If combined with --slurp, then the entire input is passed to the filter as a single long string."}, {"cmd": "jq", "option": "--null-input", "sent": "Dont read any input at all!"}, {"cmd": "jq", "option": "--null-input", "sent": "Instead, the filter is run once using null as the input."}, {"cmd": "jq", "option": "--null-input", "sent": "This is useful when using jq as a simple calculator or to construct JSON data from scratch."}, {"cmd": "jq", "option": "--compact-output", "sent": "By default, jq pretty-prints JSON output."}, {"cmd": "jq", "option": "--compact-output", "sent": "Using this option will result in more compact output by instead putting each JSON object on a single line."}, {"cmd": "jq", "option": "--tab", "sent": "Use a tab for each indentation level instead of two spaces."}, {"cmd": "jq", "option": "--indent", "sent": "Use the given number of spaces (no more than 8) for indentation."}, {"cmd": "jq", "option": "--color-output", "sent": "By default, jq outputs colored JSON if writing to a terminal."}, {"cmd": "jq", "option": "--color-output", "sent": "You can force it to produce color even if writing to a pipe or a file using -C, and disable color with -M. Colors can be configured with the JQ_COLORS environment variable (see below)."}, {"cmd": "jq", "option": "--monochrome-output", "sent": "By default, jq outputs colored JSON if writing to a terminal."}, {"cmd": "jq", "option": "--monochrome-output", "sent": "You can force it to produce color even if writing to a pipe or a file using -C, and disable color with -M. Colors can be configured with the JQ_COLORS environment variable (see below)."}, {"cmd": "jq", "option": "--ascii-output", "sent": "jq usually outputs non-ASCII Unicode codepoints as UTF-8, even if the input specified them as escape sequences (like \\u03bc)."}, {"cmd": "jq", "option": "--ascii-output", "sent": "Using this option, you can force jq to produce pure ASCII output with every non-ASCII character replaced with the equivalent escape sequence."}, {"cmd": "jq", "option": "--unbuffered", "sent": "Flush the output after each JSON object is printed (useful if youre piping a slow data source into jq and piping jqs output elsewhere)."}, {"cmd": "jq", "option": "--sort-keys", "sent": "Output the fields of each object with the keys in sorted order."}, {"cmd": "jq", "option": "--raw-output", "sent": "With this option, if the filters result is a string then it will be written directly to standard output rather than being formatted as a JSON string with quotes."}, {"cmd": "jq", "option": "--raw-output", "sent": "This can be useful for making jq filters talk to non-JSON-based systems."}, {"cmd": "jq", "option": "-f", "sent": "Read filter from the file rather than from a command line, like awks -f option."}, {"cmd": "jq", "option": "-f", "sent": "You can also use # to make comments."}, {"cmd": "jq", "option": "-Ldirectory", "sent": "Prepend directory to the search list for modules."}, {"cmd": "jq", "option": "-Ldirectory", "sent": "If this option is used then no builtin search list is used."}, {"cmd": "jq", "option": "-Ldirectory", "sent": "See the section on modules below."}, {"cmd": "jq", "option": "-e", "sent": "Sets the exit status of jq to 0 if the last output values was neither false nor null, 1 if the last output value was either false or null, or 4 if no valid result was ever produced."}, {"cmd": "jq", "option": "-e", "sent": "Normally jq exits with 2 if there was any usage problem or system error, 3 if there was a jq program compile error, or 0 if the jq program ran."}, {"cmd": "jq", "option": "-e", "sent": "Another way to set the exit status is with the halt_error builtin function."}, {"cmd": "jq", "option": "--arg", "sent": "This option passes a value to the jq program as a predefined variable."}, {"cmd": "jq", "option": "--arg", "sent": "If you run jq with --arg foo bar, then $foo is available in the program and has the value bar."}, {"cmd": "jq", "option": "--arg", "sent": "Note that value will be treated as a string, so --arg foo 123 will bind $foo to 123."}, {"cmd": "jq", "option": "--arg", "sent": "Named arguments are also available to the jq program as $ARGS.named."}, {"cmd": "jq", "option": "--argjson", "sent": "This option passes a JSON-encoded value to the jq program as a predefined variable."}, {"cmd": "jq", "option": "--argjson", "sent": "If you run jq with --argjson foo 123, then $foo is available in the program and has the value 123."}, {"cmd": "jq", "option": "--slurpfile", "sent": "This option reads all the JSON texts in the named file and binds an array of the parsed JSON values to the given global variable."}, {"cmd": "jq", "option": "--slurpfile", "sent": "If you run jq with --argfile foo bar, then $foo is available in the program and has an array whose elements correspond to the texts in the file named bar."}, {"cmd": "jq", "option": "--argfile", "sent": "Do not use."}, {"cmd": "jq", "option": "--args", "sent": "Remaining arguments are positional string arguments."}, {"cmd": "jq", "option": "--args", "sent": "These are available to the jq program as $ARGS.positional[]."}, {"cmd": "jq", "option": "--jsonargs", "sent": "Remaining arguments are positional JSON text arguments."}, {"cmd": "jq", "option": "--jsonargs", "sent": "These are available to the jq program as $ARGS.positional[]."}, {"cmd": "jq", "option": "--run-tests", "sent": "Runs the tests in the given file or standard input."}, {"cmd": "jq", "option": "--run-tests", "sent": "The input consists of comment lines, empty lines, and program lines followed by one input line, as many lines of output as are expected (one per output), and a terminating empty line."}, {"cmd": "jq", "option": "--run-tests", "sent": "Compilation failure tests start with a line containing only %%FAIL, then a line containing the program to compile, then a line containing an error message to compare to the actual."}, {"cmd": "jq", "option": "--run-tests", "sent": "Be warned that this option can change backwards-incompatibly."}], "implicit_rsent": [[{"cmd": "jq", "option": "--color-output", "sent": "By default, jq outputs colored JSON if writing to a terminal.", "predicate": "color", "object": "json", "prt": "", "tree": [[","], [[["jq"], [["outputs"]]], [["colored"], [["JSON"]], ["if"], [[["writing"], [["to"], [["a"], ["terminal"]]]]]]], ["."]]}, {"cmd": "jq", "option": "--monochrome-output", "sent": "By default, jq outputs colored JSON if writing to a terminal.", "predicate": "color", "object": "json", "prt": "", "tree": [[","], [[["jq"], [["outputs"]]], [["colored"], [["JSON"]], ["if"], [[["writing"], [["to"], [["a"], ["terminal"]]]]]]], ["."]]}], [{"cmd": "jq", "option": "--args", "sent": "Remaining arguments are positional string arguments.", "predicate": "remain", "object": "", "prt": "", "tree": [[["It"]], [["remains"], [["arguments"]], [["are"], [["positional"], ["string"], ["arguments"]]]], ["."]]}, {"cmd": "jq", "option": "--jsonargs", "sent": "Remaining arguments are positional JSON text arguments.", "predicate": "remain", "object": "", "prt": "", "tree": [[["It"]], [["remains"], [["arguments"]], [["are"], [["positional"], ["JSON"], ["text"], ["arguments"]]]], ["."]]}]]}